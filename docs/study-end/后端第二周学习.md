# 后端第二周学习

## 1. 脉络梳理

### 1.1 调试和模版引擎

![调试和模版引擎](E:\SpringProject\调试和模版引擎.png)

### 1.2 日志管理

![日志管理](E:\SpringProject\日志管理.png)



## 2. 调试和模板引擎

### 2.1 Spring Boot 调试

#### 2.1.1 什么是调试

调试是软件开发中⾮常重要的⼀部分， 它可以帮助开发⼈员在代码中找到错误（ bug），理解程序 的运⾏逻辑， 并验证应⽤程序的⾏为是否符合预期 。在 Spring Boot 中，调试的⽅式与标准的Java 项⽬调试类似，但由于 Spring Boot 是⼀个微框架，整合了⼤量的第三⽅库， 因此调试过程 中需要注意其特有的机制。

#### 2.1.2 常见的调试方式

调试 Spring Boot 应⽤程序的⽅式有多种， 包括：

- 使⽤⽇志跟踪；

- 使⽤集成开发环境（ IDE） 如 IntelliJ IDEA 的断点调试；

- 远程调试。

#### 2.1.3 使用日志进行测试

Spring Boot 集成了⾮常强⼤的⽇志功能 。通过⽇志输出， 开发者可以查看应⽤程序运⾏时的状态 和数据， 了解程序的执⾏流。

##### 2.1.3.1 启用日志

Spring Boot 默认使⽤ Logback ⽇志框架， 配置⾮常简单 。在 application.properties 或 application.yml 文件中配置日志级别：

 ```vue
 logging:
 	level:
 		root: info
 		com.example.demo: debug
 ```

其中：

- root 表示全局⽇志级别， INFO 表示⽇志将显示信息级别及其以上（包括 WARN、 ERROR）。
- com.example.demo 是包的路径， DEBUG 级别将显示详细的调试信息。

##### 2.1.3.2 查看日志输出

运⾏ Spring Boot 应⽤程序时，⽇志会在控制台输出。如果需要更详细的⽇志，可以将⽇志级别 调为 DEBUG ，这样可以查看每个操作的详细信息。

⽇志调试是⼀种⽆侵⼊的⽅式，即不需要修改代码结构或应⽤逻辑就可以查看程序运⾏中的状态。 但⽇志调试只能帮助我们观察现象，⽆法实时控制应⽤执⾏流程。

#### 2.1.4 断点调试

断点调试是⼀种更强⼤的调试⽅式，允许我们在代码的关键位置设置断点，程序执⾏到断点处时会 暂停，开发者可以逐步检查应⽤状态、变量值，甚⾄⼿动控制程序的执⾏流。 

确保你以调试模式启动应⽤程序（如通过 Debug 按钮启动），并且断点会命中了正在执⾏的代码。

![image-20240913123306712](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913123306712.png)

##### 2.1.4.1 在 IDE 中设置断点

以 IntelliJ IDEA 为例，设置断点的步骤⾮常简单： 1. 打开项⽬，找到你想要调试的类或⽅法； 2. 在⾏号旁边的空⽩区域点击，红点会出现，这就是断点（BreakPoint）。 例如：

![image-20240913142510441](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913142510441.png)

##### 2.1.4.2 以调试模式启动应用程序

在调试模式下启动 Spring Boot 应⽤⾮常简单： 

1. 在 IntelliJ IDEA 中，点击类的左侧，选择 Debug 选项启动应⽤程序。对于 Spring Boot 项⽬，可以直接右键点击启动类 Application ，选择 Debug 选项；

![image-20240913142531003](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913142531003.png)

2. 在调试过程中，当程序执⾏到断点处时，应⽤会暂停，IDE 会显示调试窗⼝，可以查看当前执 ⾏的线程、局部变量、全局变量等信息。

![image-20240913144720115](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913144720115.png)

##### 2.1.4.3 使用条件断点

在某些场景下，可能只想在特定条件下暂停程序执⾏。这时可以使⽤ 条件断点。右键点击断点， 选择 "条件"，输⼊你想要的条件表达式，例如 name.equals("John") 。

![image-20240913144811896](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913144811896.png)

这样设置后，只有在传递“John”参数的时候，才会进⼊断点，其余参数则不会进⼊。

### 2.2 Spring Boot 开发者工具

Spring Boot DevTools 是⼀个极为强⼤的开发⼯具，专⻔为提⾼开发效率设计。它包括⾃动重 启、热加载、禁⽤缓存等功能，让开发者可以快速查看代码修改的效果，⽆需频繁⼿动重启应⽤。 DevTools 能极⼤地加快开发迭代速度，尤其是在前后端分离或开发⼤型项⽬时，它的作⽤尤为显著。

#### 2.2.1 添加 Spring Boot DevTools 依赖

⾸先，确保在项⽬中添加了 Spring Boot DevTools 依赖：

![image-20240913144911670](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913144911670.png)

#### 2.2.2 配置热更新

##### 2.2.2.1 设置 IDEA 触发更新的动作

打开 Run/Debug Configurations

![image-20240913145109718](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145109718.png)

点击 Modify options，如图勾选：

![image-20240913145213467](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145213467.png)

确定后，启动应⽤，然后按图中操作，不⽤重启，即可实现热更新:

![image-20240913145427909](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145427909.png)

![image-20240913145334800](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145334800.png)

##### 2.2.2.2 手动编译触发热更新

每次修改完代码，⼿动编译：ctrl + f9，会触发热更新：

![image-20240913145524284](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145524284.png)

效果同上。

#### 2.2.3 远程调试

DevTools 还允许开发者进⾏远程调试和管理。通过 Remote Spring Boot DevTools ，可 以连接远程运⾏的应⽤程序并进⾏实时调试。

启⽤远程调试：

![image-20240913145844221](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145844221.png)

连接远程服务器：

- 配置完成后，可以通过 IDE（如 IntelliJ IDEA）连接远程服务器，并进⾏调试。

#### 2.2.4 DevTools 的其他高级功能

##### 2.2.4.1 禁用特定开发环境功能

在某些特殊场景下，我们可能希望在某些开发环境中禁⽤ DevTools 功能。例如，可以禁⽤⾃动重 启或其他功能：

![image-20240913145919957](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145919957.png)

这样设置后，每次修改完代码，不管⼿动编译编译还是⾃动编译，都⽆法热更新，必须直接重启。

##### 2.2.4.2 监听文件的更改

Spring Boot DevTools 提供⽂件变更监听的功能。可以通过 spring.devtools.restart.ad ditional-paths 监控多个路径：

![image-20240913145950549](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913145950549.png)

##### 2.2.4.3 示例：完整的application,yml 配置

以下是⼀个完整的 application.yml ⽂件，展示了如何配置 Spring Boot DevTools 的常⻅ 功能：

![image-20240913150008480](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913150008480.png)

通过 Spring Boot DevTools，开发者可以显著提⾼开发速度和调试效率。⾃动重启、热加载、禁 ⽤缓存等功能可以帮助开发者在代码修改后⽴即看到效果，⽽不需要⼿动重启或刷新⻚⾯。通过 application.yml ，可以灵活配置 DevTools 的⾏为，适应不同的开发环境需求。同时， DevTools 的远程调试功能让我们可以轻松管理和调试运⾏在服务器上的应⽤。 

掌握 DevTools 的使⽤，不仅能提⾼⽇常开发的体验，还能更加⾼效地调试和优化 Spring Boot 应⽤。

### 2.3 模版引擎 Thymeleaf

#### 2.3.1 基本概念

Thymeleaf 是⼀个现代的、服务器端的 Java 模板引擎，专⻔⽤于在基于 MVC 的 Web 应⽤程序 中⽣成 HTML、XML、JavaScript、CSS 和纯⽂本。它与 Spring Boot 集成良好，⼴泛⽤于动态 渲染前端⻚⾯。它可以动态⽣成 HTML ⻚⾯，并⽀持丰富的功能和语法，⽐如条件渲染、循环、 表单处理和国际化⽀持，帮助开发者⾼效地构建动态 Web 应⽤。 

Thymeleaf 的主要特点如下： 

1. 与 HTML 兼容：Thymeleaf 模板⽂件使⽤标准的 HTML5 语法，这意味着即使没有服务器⽀ 持，Thymeleaf 模板也能在浏览器中直接显示静态⻚⾯。因此，设计师和开发者可以共享同 ⼀个 HTML ⽂件，进⾏⽆缝协作； 
2. 易于集成：Thymeleaf 与 Spring Framework（特别是 Spring Boot）⽆缝集成。它可以直接 通过 Spring MVC 传递的数据模型渲染动态内容； 
3. 服务器端模板：Thymeleaf 是服务器端模板引擎，意味着所有的模板解析和渲染⼯作在服务 器端进⾏，⽣成的最终 HTML 被发送到客户端浏览器； 
4. ⽀持多种内容格式：除了 HTML，Thymeleaf 还⽀持 XML、⽂本、JavaScript 和 CSS 等多 种格式。 
5. 丰富的内置功能：Thymeleaf 提供了很多内置的功能和语法，⽐如条件判断、循环、国际化 ⽀持、模板继承等，极⼤地简化了动态⻚⾯的⽣成。 

Thymeleaf 的基本语法如下： 

1. 变量表达式： 使⽤ ${} 来访问模型中的变量。

```html
<p th:text="${user.name}">用户名</p>
```

上述代码会将 user 对象中的 name 属性值渲染到 标签中。

2. 条件判断： 使⽤ th:if 进⾏条件渲染。

```html
<p th:if="${user.age > 18}">成年用户</p>
```

3. 循环遍历： 使⽤ th:each 遍历集合。

```html
<ul>
    <li th:each="item : ${items}" th:text="${item.name}"></li>
</ul>
```

4. URL 处理： 使⽤ @{} 来⽣成链接。

```html
<a th:href="@{/user/profile(id=${user.id})}">查看资料</a>
```

#### 2.3.2 使用入门

在开发过程中，DevTools 可以⾃动禁⽤⼀些缓存（例如模板引擎的缓存），以确保每次请求都能 加载最新的内容。尤其在使⽤模板引擎（如 Thymeleaf）时，禁⽤缓存⾮常重要。 

⾸先添加 Thymeleaf 依赖：

![image-20240913150802624](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913150802624.png)

然后在 application.yml 中配置 Thymeleaf 缓存禁⽤：

![image-20240913150828141](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913150828141.png)

解释：

- spring.thymeleaf.cache: false ：禁⽤ Thymeleaf 模板的缓存，以确保每次请求都 加载最新的模板⽂件。

创建⼀个简单的 Spring Boot 控制器，⽤于返回 Thymeleaf ⻚⾯

```java
package top.zhu.springboot.thymeleaf;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @GetMapping
    public  String hello(String name) {
        String greeting = "Hello," + name + "!";
        return greeting;
    }

    @GetMapping("/sum")
    public  String sum(int sum) {
        int Sum = 0;
        for (int i = 1 ; i <= sum ; i++) {
            Sum += i;
        }
        return String.valueOf(Sum);
    }
}

```

解释：

- @Controller ：声明这是⼀个 Spring MVC 控制器； 
- Model ：Spring MVC 提供的对象，⽤于将数据传递到前端⻚⾯； 
- @GetMapping("/hello") ：映射 /hello 请求到该⽅法； 
- model.addAttribute("message", "Hello, Thymeleaf!") ：将 message 变量 传递给前端⻚⾯； 
- 返回 hello 视图名称（即 hello.html ⻚⾯）。

创建 Thymeleaf 模板⻚⾯ 

在 src/main/resources/templates ⽬录下创建 hello.html ：

```html
<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<h1>页面显示内容</h1>
<h2 th:text="${message}"></h2>
</body>
</html>
```

解释：

- th:text="${message}" ：Thymeleaf 标签，⽤于动态绑定控制器中传递的数据； 

- message 是从 HelloController 传递到⻚⾯的模型数据。

启动应⽤后，访问浏览器中的[localhost:8082/?name="朱浩然"](http://localhost:8082/?name="朱浩然")，⻚⾯将显示 "Hello, 朱浩然!" 。

![image-20240913151030290](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913151030290.png)

#### 2.3.3 待办清单练习

使⽤ Spring Boot 和 Thymeleaf 实现的简单 待办清单 应⽤示例，可以使⽤这个示例来创建、查 看、更新和删除待办事项。

##### 2.3.3.1 功能需求

1. 展示待办事项：列出所有待办事项，显示任务内容和状态（完成/未完成）； 
2. 添加新任务：通过表单添加新的待办事项； 
3. 更新任务状态：将任务标记为完成或未完成； 
4. 删除任务：从列表中删除已完成或不需要的任务。

##### 2.3.3.2 项目结构

1. 控制器层：处理⽤户请求（创建、更新、删除任务）； 
2. 服务层（可选）：处理业务逻辑； 
3. 模型层：定义待办任务实体； 
4. 视图层：使⽤ Thymeleaf 渲染⻚⾯。

##### 2.3.3.3 步骤

###### 2.3.3.3.1 创建 Spring Boot 项目

创建⼀个 Spring Boot 项⽬，选择以下依赖： 

- Spring Web； 
- lombok
- Thymeleaf； 
- Spring Boot DevTools（可选，⽤于开发时⾃动重启）。

###### 2.3.3.3.2 项目代码实现

在 model 包下创建 Task 类，表示每个待办事项。

```java
package top.zhu.springboot.thymeleaf.model;

import lombok.Data;

@Data
public class Task {
    private Long id;
    private String name;
    private Boolean completed;

    public Task(Long id, String name) {
        this.id = id;
        this.name = name;
        this.completed = false;
    }
}

```

在 controller 包下创建 TaskController ，处理⻚⾯请求和数据交互。

```java
package top.zhu.springboot.thymeleaf.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import top.zhu.springboot.thymeleaf.model.Task;

import java.util.ArrayList;
import java.util.List;

// 非前后端分离所以用Controller
@Controller
public class TaskController {
    private List<Task> tasks = new ArrayList<Task>();

    @GetMapping("/taskList")
    public String taskList(Model model) {
        model.addAttribute("tasks", tasks);
        return "taskList";
    }

    @PostMapping("/addTask")
    public String addTask(@RequestParam String name) {
        Long id = (long) (tasks.size() + 1);
        Task task = new Task(id , name);
        tasks.add(task);
        return "redirect:/taskList";
    }

    @PostMapping("/deleteTask")
    public String deleteTask(@RequestParam Long id) {
        tasks.removeIf(task -> task.getId().equals(id));
        return "redirect:/taskList";
    }

    @PostMapping("/updateTask")
    public String updateTask(@RequestParam Long id) {
        Task task = tasks.stream()
                .filter(t -> t.getId().equals(id))
                .findFirst()
                .orElse(null);
        if (task != null) {
            task.setCompleted(!task.getCompleted());
        }
        return "redirect:/taskList";
    }
}

```

在 src/main/resources/templates/ ⽬录下创建 taskList.html 。

```html
<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="/css/style.css">
    <title>Todo List</title>
</head>
<body>
<h1>待办清单</h1>
<!--新增任务-->
<form action="/addTask" method="post">
    <input type="text" name="name" placeholder="请输入任务名称" id="name">
    <button type="submit">添加任务</button>
</form>

<!--显示任务列表-->
<ul>
    <li th:each="task : ${tasks}">
        <span th:text="${task.name}" th:classappend="${task.completed} ? 'completed' : ''"></span>
        <form action="/updateTask" method="post" style="display: inline">
            <input type="hidden" name="id" th:value="${task.id}">
            <button type="submit">切换状态</button>
        </form>
        <form action="/deleteTask" method="post" style="display: inline">
            <input type="hidden" name="id" th:value="${task.id}">
            <button type="submit">删除</button>
        </form>
    </li>
</ul>

</body>
</html>
```

在 src/main/resources/static/css/ ⽬录下创建 style.css ⽂件，添加简单样式。

```css
body {
    font-family: Arial,sans-serif;
    max-width: 600px;
    margin: 0 auto;
}

h1{
    color: #333;
    text-align: center;
}

ul{
    list-style-type:  none;
    padding: 0;
}

li{
    margin-bottom:  10px;
}

.completed {
    text-decoration: line-through;
    color: #999;
}

button {
    background-color: #1a73e8;
    color: white;
    border: none;
    padding: 5px 10px;
    margin-left: 10px;
    cursor: pointer;
}

button:hover{
    background-color: #155ab6;
}

table{
    border-collapse:collapse;
    width: 100%;

}

th{
    background-color: #efeff0;
    text-align: left;
    padding: 10px;
    width: 160px;
}
td{
    text-align: left;
    width: 160px;
    padding: 10px;
}

body{
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    border-radius: 20px;
    padding: 20px;
}
```

###### 2.3.3.3.3 运行项目

1. 启动 Spring Boot 应⽤程序：

```
mvn spring-boot:run
```

2. 访问应⽤⾸⻚：http://localhost:8082/taskList

可以通过表单添加新的待办任务；任务列表会显示所有待办事项；还可以点击按钮切换任务的完成状态或删除任务。

![image-20240913152709377](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913152709377.png)

##### 2.3.3.4 扩展功能

1. 使⽤数据库：将任务列表存储在数据库中，⽽不是内存中；  
2. 任务优先级：为每个任务添加优先级，并根据优先级排序任务；  
3. 任务截⽌⽇期：为任务添加截⽌⽇期，并显示离截⽌⽇期最近的任务； 
4. 分⻚显示：当任务数量较多时，可以实现分⻚功能。



## 3. 日志管理

### 3.1 Spring Boot 日志框架

Spring Boot 框架内部所有⽇志的记录使⽤的是 Apache 开源的 Commons Logging ⽇志框架，它只是⼀种⽇志⻔⾯，提供了⼀套⽇志规范接⼝，底层的⽇志框架实现是可以⾃由切换的。

⽇志⻔⾯主要是为了给 Java ⽇志访问提供⼀套标准、规范的 API 框架，其主要意义在于提供接⼝，具体的实现可以交由其他⽇志框架来实现，例如 log4j 和 logback 等。

Spring Boot 提供了以下⼏种⽇志框架的⾃动配置：

| 日志框架          | 启动器                      |
| ----------------- | --------------------------- |
| Java Util Logging | spring-boot-starter-logging |
| Logback           | spring-boot-starter-logging |
| Log4J2            | spring-boot-starter-log4j2  |

其中 spring-boot-starter-logging ⽇志启动器是 Spring Boot Starter 启动器默认集成 的，⽆需⾃⾏导⼊，这个可以从任何⼀个包括 spring-boot-starter 的启动器包中找到，⽐如 spring-boot-starter-web 依赖了 spring-boot-starter ，⽽ spring-boot-sta rter 就会依赖 spring-boot-starter-logging ：

```xml
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-logging</artifactId>
 <version>3.3.3</version>
 <scope>compile</scope>
</dependency>
```

所以，任何⼀个 spring-boot-starter-* 启动器都会默认导⼊⼀个 spring-boot-starte r-logging 启动器依赖，如果有引⼊其他官⽅的 Spring Boot Starter，则⽆需⾃⾏导⼊ sprin g-boot-starter-logging 启动器依赖。 

Spring Boot 默认集成的是 Logback ⽇志框架，以及 Slf4j ⽇志⻔⾯。 

如下图所示，可以从 spring-boot-starter-web 依赖树中看到它包含了默认⽇志框架 Logb ack 及其他的桥接器：

![image-20240913153648244](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913153648244.png)

### 3.2 Spring Boot 日志格式

Spring Boot ⽇志格式如下：

```bash
2024-7-17T09:38:15.072+08:00 INFO 66672 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8443 (https) 8080 (http) with context path ''
```

⽇志主要包含以下信息： 

- ⽇期时间：精确到毫秒，易于排序 
- ⽇志级别：如 INFO、DEBUG、ERROR 等 
- 应⽤进程 ID，⽐如上⾯的 66672 
- 分隔符（---）：⽤来区分实际开始的⽇志 
- 线程名称：⽐如上⾯的 [ main] 
- ⽇志名称：⼀般是指⽇志输出当前类缩写 
- ⽇志具体内容

### 3.3 Spring Boot 控制台日志

Spring Boot 默认从控制台输出⽇志，默认情况下，会记录 ERROR、WARN、INFO 级别的⽇ 志，如果要让应⽤输出更多⽇志，可以在应⽤启动时通过使⽤ --debug 标志来启⽤调试模式，⽐ 如以下示例：

```bash
java -jar springboot.jar --debug
```

需要注意的是：

启⽤应⽤的 debug 调试模式，并不是让应⽤启⽤并输出所有的 DEBUG 级别⽇志，⽽是可以让应 ⽤输出更多的框架核⼼⽇志，框架的核⼼⽇志包括嵌⼊式容器、Spring Boot 等这部分组件更多的 ⽇志。

另外，还可以开启应⽤的 trace 追踪模式，⽇志要⽐ debug 调试模式更详细，使⽤⽅法、注意事 项和 debug 调试模式是⼀样的，⽐如以下示例：

```bash
java -jar springboot.jar --trace
```

### 3.4 Spring Boot 日志文件

Spring Boot 默认从控制台输出⽇志，⽽不会将⽇志写到⽇志⽂件当中，这在实际项⽬中肯定是不 可⾏的，实际项⽬不可能⼀直开着控制台，控制台⽇志随时会挂失，输出到⽇志⽂件可有利于归档 并排查 N 天之前的⽇志。 

将⽇志输出到⽇志⽂件，可以设置以下两个属性：

| 配置参数          | 说明                       | 示例           |
| ----------------- | -------------------------- | -------------- |
| logging.file.name | 指定需要输出的⽇志⽂件名称 | springboot.log |
| logging.file.path | 指定需要输出的⽇志⽂件路径 | /var/log       |

此时默认⽇志⽂件为 spring.log

Spring Boot 根据以上两个配置参数来输出⽇志⽂件，可以任⽤⼀个，也可以两个结合使⽤，可以 是指定的路径，也可以是当前⽬录的相对路径，⽐如以下⽇志⽂件配置：

```yaml
logging:
  file:
  name: ./logs/springboot.log
```

应⽤启动之后，会在多模块项⽬的根⽬录⾃动创建 logs/springboot.log ⽇志⽂件：

![image-20240913154141669](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913154141669.png)

原理就是在 Spring Boot 主包中的⾃动配置⽂件中注册了⼀个 LoggingApplicationListene r 监听器，然后监听了 ApplicationEnvironmentPreparedEvent 事件：

```java
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentP
reparedEvent event) {
 SpringApplication springApplication = event.getSpringApplication();
 if (this.loggingSystem == null) {
 this.loggingSystem = LoggingSystem.get(springApplication.getClassL
oader());
 }
 initialize(event.getEnvironment(), springApplication.getClassLoader())
;
}
protected void initialize(ConfigurableEnvironment environment, ClassLoader
classLoader) {
 getLoggingSystemProperties(environment).apply();
 this.logFile = LogFile.get(environment);
 if (this.logFile != null) {
 this.logFile.applyToSystemProperties();
 }
 this.loggerGroups = new LoggerGroups(DEFAULT_GROUP_LOGGERS);
 initializeEarlyLoggingLevel(environment);
 initializeSystem(environment, this.loggingSystem, this.logFile);
 initializeFinalLoggingLevels(environment, this.loggingSystem);
 registerShutdownHookIfNecessary(environment, this.loggingSystem);
}
```

然后在 initialize 初始化⽅法中通过 LogFile#_get_ ⽅法获取具体的⽇志⽂件：

```java
public static LogFile get(PropertyResolver propertyResolver) {
 String file = propertyResolver.getProperty(FILE_NAME_PROPERTY);
 String path = propertyResolver.getProperty(FILE_PATH_PROPERTY);
 if (StringUtils.hasLength(file) || StringUtils.hasLength(path)) {
 return new LogFile(file, path);
 }
 return null;
}
```

Spring Boot 在获取⽇志配置的时候为什么不是⽤ @ConfigurationProperties 注解绑定配 置，⽽是⼿动获取配置呢？这是因为在⽇志初始化是在 ApplicationContext 创建之前，所以此时 还⽆法获取环境中的配置。

### 3.5 Spring Boot 日志级别

Spring Boot ⽀持的所有⽇志级别如下：

| 日志级别 | 说明     |
| -------- | -------- |
| OFF      | 关闭日志 |
| TRACE    | 追踪     |
| DEBUG    | 调试     |
| INFO     | 信息     |
| WARN     | 警告     |
| ERROR    | 错误     |
| FATAL    | 致使     |

我们来了解下常⻅的⽇志的⼏个级别： 

1. TRACE：追踪。⼀般上对核⼼系统进⾏性能调试或者跟踪问题时有⽤，此级别很低，⼀般上是不开启的，开启后⽇志会很快就打满磁盘的； 
2. DEBUG：调试。这个⼤家应该不陌⽣了，开发过程中主要是打印记录⼀些运⾏信息之类的； 
3. INFO：信息。这个是最常⻅的了，⼤部分默认就是这个级别的⽇志。⼀般上记录了⼀些交互 信息，⼀些请求参数等等。可⽅便定位问题，或者还原现场环境的时候使⽤。此⽇志相对来说 是⽐较重要的； 
4. WARN：警告。这个⼀般上是记录潜在的可能会引发错误的信息。⽐如启动时，某某配置⽂件 不存在或者某个参数未设置之类的；
5. ERROR：错误。这个也是⽐较常⻅的，⼀般上是在捕获异常时输出，虽然发⽣了错误，但不 影响系统的正常运⾏。但可能会导致系统出错或是宕机等。 
6. FATAL：致命。该级别的⽇志⽤于表示系统中出现了⾮常严重的错误，导致系统⽆法继续运 ⾏或者处于崩溃状态。 FATAL 级别通常是最⾼的⽇志级别，⽤于记录那些不可恢复的错误 

⽇志级别从⼩到⼤为 trace < debug < info < warn < error ，由于通常⽇志框架默认⽇志级别设 置为 INFO，因此 trace 和 debug 级别的⽇志都看不到。 

最新的所有⽀持⽇志级别可以查看 LogLevel 这个类的源码：

```java
public enum LogLevel {
 TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
}
```

Spring Boot 默认会输出 INFO 级别及以上的⽇志，另外，Logback 不⽀持 FATAL ⽇志级别， 它会映射到 ERROR 级别上⾯。 

⽇志级别配置格式为：

```yaml
logging:
 level:
 root: INFO
 org.springframework: WARN
```

这⾥配置了根包的⽇志级别为 INFO， org.springframework 包的⽇志级别为 WARN。

### 3.6 Spring Boot 日志分组

上⾯⼀节在配置对应包的⽇志级别的时候，需要⼀个个包的指定⽇志级别，如果要指定的包⽐较 多，再为它们批量更换⽇志级别就⽐较麻烦，所以，Spring Boot 提供了⽇志分组功能，可以把相 关的包配置成⼀个⽇志组，然后再针对⽇志组统⼀设置⽇志级别。 

如下配置示例：

```yaml
logging:
 group:
 tomcat: org.apache.catalina,org.apache.coyote,org.apache.tomcat
 level:
 tomcat: ERROR
```

这⾥配置了⼀个 Tomcat 组，组下⾯包含了三个包，然后把该⽇志分组设置为 Error ⽇志级别， 即组下⾯的所有包都统⼀设置了，如果现在要更换这些包的⽇志级别，只需要更换该组的⽇志级别 即可，简单⽅便。 

Spring Boot 也提供了以下⼏个可开箱即⽤的⽇志组：

| 日志组名称                                                   | 包含的包                       |
| ------------------------------------------------------------ | ------------------------------ |
| web                                                          | org.springframework.core.codec |
| org.springframework.http                                     |                                |
| org.springframework.web                                      |                                |
| org.springframework.boot.actuate.endpoint. web               |                                |
| org.springframework.boot.web.servlet.Servle tContextInitializerBeans |                                |
| sql                                                          | org.springframework.jdbc.core  |
| org.hibernate.SQL                                            |                                |
| org.jooq.tools.LoggerListener                                |                                |

意味着这些⽇志组可以直接配置⽇志级别使⽤，不需要再额外配置⽇志组，⽐如以下配置示例：

```
logging:
 level:
 web: INFO
```

这样配置后，web ⽇志组下⾯的所有包都是 INFO ⽇志级别。

### 3.7 Spring Boot 日志归档

Spring Boot 在达到默认的 10MB 之后就会⾃动归档，如果使⽤的是默认的 Logback ⽇志框 架，可以直接在 application 配置⽂件中配置⽇志滚动规则，其他⽇志框架需要在其⽇志配置 ⽂件中配置（如：Log4J2）。 

Logback ⽇志归档配置参数对应的参数类为 LogbackLoggingSystemProperties 类，具体 参数如下表格所示：

| ⽇志滚动配置参数                                     | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| logging.logback.rollingpolicy.file-name-pattern      | 创建⽇志归档的⽂件名模式                                     |
| logging.logback.rollingpolicy.clean-history-on-start | 应⽤程序启动时是否进⾏⽇志归档清理                           |
| logging.logback.rollingpolicy.max-file-size          | ⽇志归档⽇志⽂件的最⼤⽂件容量，超过就进⾏ 归档（默认为 10 MB） |
| logging.logback.rollingpolicy.total-size-cap         | ⽇志归档⽂件可占⽤的最⼤容量，超过会删除旧 的归档⽇志⽂件    |
| logging.logback.rollingpolicy.max-history            | ⽇志存档⽂件要保留的的最⼤天量（默认为 7 天）                |

如以下参考配置：

```yaml
logging:
 file:
 name: ./logs/springboot.log
 logback:
 rollingpolicy:
 max-file-size: 1KB
```

这⾥我们指定⽂件⽇志超到 1KB 就进⾏归档，实际项⽬中请根据⾃⼰的需求进⾏配置。 应⽤重启后再来看下⽇志⽬录：

![image-20240913155249648](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913155249648.png)

可以看到应⽤⽣成了好⼏个⽇志归档⽂件，⽇志⽂件默认是按⽇期进⾏归档的，同⼀天的多次归档 ⼜会按索引进⾏归档，索引从 0 开始。

### 3.8 Spring Boot logback 日志框架配置

Logback 既可以通过 application.yml 配置⽂件进⾏⽇志的配置，⼜可以通过 logbackspring.xml 进⾏⽇志的配置。简单的情况下，使⽤全局配置⽂件 application.yml 进⾏配置就够 了，如果⽇志输出需求特别复杂⽽且需求⽐较个性化，可以考虑使⽤ logback-spring.xml 的配置 ⽅式。

#### 3.8.1 application 配置文件实现日志配置

在 applicaition.yml ⽂件中进⾏⽇志的配置：

```yaml
logging:
 level:
 root: info
 com.example.demo.controller: debug
 file:
 path: ./logs
 name: ./logs/spring-boot-log.log
 logback:
 rollingpolicy:
 max-file-size: 10MB
 max-history: 10
 pattern:
 console: '%red(%d{yyyy-MM-dd HH:mm:ss}) %green([%thread]) %highlight(% -5level) %boldMagenta(%logger{10}) - %cyan(%msg%n)'
 file: '%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger : %msg% n'
```

- logging.level.root=info 指定整个系统的默认⽇志级别是 info，⽇志级别统⼀化； 
- logging.level.com.example.demo.controller=debug，指定某个特定的 package 的⽇志级别 是 debug，⽇志级别个性化。优先级⻆度，个性配置⼤于统⼀配置； 
- logging.file.path 将⽇志输出到指定⽬录，如果不指定 logging.file.name，⽇志⽂件的默认名 称是spring.log。配置了logging.file.name之后，logging.file.path 配置失效； 
- ⽆论何种设置，Spring Boot 都会⾃动按天分割⽇志⽂件，也就是说每天都会⾃动⽣成⼀个新 的 log ⽂件，⽽之前的会⾃动打成压缩包； 
- 可以设置 logging.logback.rollingpolicy.max-file-size=10MB 分割的每个⽇志的⽂件最⼤容量，超过这个消息后⽇志继续分隔； 
- 可以设置保留的⽇志时间 logging.logback.rollingpolicy.max-history=10，以天为单位； 
- logging.pattern.console 控制台输出⽇志的格式，为了在控制台调试时候显示效果更清晰， 为⽇志增加了颜⾊，red、green 等等； 
- logging.pattern.file 输出到⽂件中的⽇志的格式。

#### 3.8.2 使用 logback-spring.xml 实现日志配置

 ⼀般情况下，使⽤全局配置⽂件 application.yml 或 properties 进⾏配置就⾜够了，但是如果⽇志 输出需求特别复杂，可以考虑使⽤ logback-spring.xml 的配置⽅式。 

因为 logback 是 Spring Boot 的默认⽇志框架，所以不需要引⼊ Maven 依赖，直接在 resources 下新建 logback-spring.xml ⽂件，如下。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<configuration>
 <!-- 定义控制台⽇志输出 -->
 <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
 <encoder>
 <!-- 控制台输出格式 -->
 <pattern>
 %red(%d{yyyy-MM-dd HH:mm:ss}) %green([%thread]) %highlight
(%-5level) %boldMagenta(%logger{10}) - %cyan(%msg%n)
 </pattern>
 </encoder>
 </appender>
 <!-- 定义⽂件⽇志输出 -->
 <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAp
pender">
 <file>./logs/spring-boot-log.log</file>
 <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRolling
Policy">
 <!-- 定义⽂件名模式和归档规则 -->
 <fileNamePattern>./logs/spring-boot-log-%d{yyyy-MM-dd}.log</fi
leNamePattern>
 <!-- 每个⽂件最⼤ 1MB -->
 <maxFileSize>1MB</maxFileSize>
 <!-- 保留最多 10 个历史⽇志⽂件 -->
 <maxHistory>10</maxHistory>
 </rollingPolicy>
 <encoder>
 <!-- ⽂件输出格式 -->
 <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logge
r : %msg%n</pattern>
 </encoder>
 </appender>
 <!-- 全局⽇志级别 -->
 <root level="info">
 <appender-ref ref="CONSOLE" />
 <appender-ref ref="FILE" />
 </root>
 <!-- 定义特定包的⽇志级别 -->
 <logger name="com.example.demo.controller" level="debug" additivity="f
alse">
 <appender-ref ref="CONSOLE" />
     <appender-ref ref="FILE" />
 </logger>
</configuration>
```

解释：

1. 控制台输出 ( CONSOLE )： 
   - 使⽤ ConsoleAppender 将⽇志输出到控制台，使⽤ %highlight() 和 %colo r() 为不同部分添加颜⾊； 
   - pattern 定义了控制台的输出格式： 
     - %red(%d{yyyy-MM-dd HH:mm:ss}) ：⽇期部分为红⾊； 
     - %green([%thread]) ：线程名称为绿⾊； 
     - %highlight(%-5level) ：根据⽇志级别不同⾃动调整颜⾊； 
     - %boldMagenta(%logger{10}) ：⽇志记录器名称显示为紫⾊并加粗； 
     - %cyan(%msg%n) ：⽇志消息内容为⻘⾊。 

2. ⽂件输出 ( FILE )： 
   - 使⽤ RollingFileAppender 将⽇志输出到⽂件； 
   - file 定义了⽇志⽂件的路径和名称为 ./logs/spring-boot-log.log ； 
   - rollingPolicy 定义了滚动策略： 
     - maxFileSize ：每个⽇志⽂件最⼤为 1MB； 
     - maxHistory ：最多保留 10 个历史⽇志⽂件。 

3. 全局⽇志级别： 
   - root ⽇志级别设置为 info ，表示默认情况下只记录 INFO 及以上级别的⽇志。 

4. 特定包的⽇志级别： 
   - 对 com.example.demo.controller 包单独设置⽇志级别为 debug ，表示该包 的⽇志将记录 DEBUG 及以上级别的⽇志。

上⾯配置完成之后，可以使⽤如下代码测试⼀下，是否满⾜了需求。

```java
package top.zhu.springboot.logging.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LogController {

    private static final Logger logger = LoggerFactory.getLogger(LogController.class);

    @GetMapping("/log")
    public String logDemo() {
        logger.trace("This is a TRACE log");
        logger.debug("This is a DEBUG log");
        logger.info("This is a INFO log");
        logger.warn("This is a WARN log");
        logger.error("This is a ERROR log");
        return "Logs have been generated";
    }

}
```

启动应⽤，访问 ： http://localhost:8080/log ，观察控制台输出⽇志的格式以及⽇志⽂件：

![image-20240913160304280](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913160304280.png)







项目如下：

![image-20240913161227454](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240913161227454.png)
